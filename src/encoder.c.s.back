/*
 * 编码器模块 (动态消抖版)
 *
 * 通过 GPIO 中断计数霍尔编码器脉冲
 * 只使用 A 相，上升沿触发计数
 * 消抖时间根据速度(shared_delta)动态调整
 */

#include <rtthread.h>
#include <rtdevice.h>
#include "common.h"
#include "encoder.h"

/* 编码器计数器 (无符号，只累加) */
static volatile rt_uint32_t encoder1_count = 0;
static volatile rt_uint32_t encoder2_count = 0;

/* 上一次读取时的计数值 (用于计算增量) */
static rt_uint32_t encoder1_last_count = 0;
static rt_uint32_t encoder2_last_count = 0;

/* 初始化标志 */
static rt_bool_t encoder1_initialized = RT_FALSE;
static rt_bool_t encoder2_initialized = RT_FALSE;

/* ================= 动态消抖机制 (微秒级精度) ================= */

/*
 * 使用 24MHz 硬件定时器实现微秒级消抖
 * SOC_TIMER_FREQ = 24000000, 每微秒 24 个计数
 */
#include <clint.h>  /* for SysTimer_GetLoadValue() */

#define TIMER_COUNTS_PER_US  24   /* 24MHz = 24 counts/us */
#define TIMER_COUNTS_PER_MS  24000  /* 24MHz = 24000 counts/ms */

/* 上一次有效中断的时间戳 (硬件定时器计数值) */
static volatile rt_uint64_t encoder1_last_time = 0;
static volatile rt_uint64_t encoder2_last_time = 0;

/* 
 * 消抖时间阈值 (单位: 微秒)
 * 可动态调整: 高速时减小，低速时增大
 * 默认值: 1000us = 1ms
 */
static volatile rt_uint32_t encoder1_debounce_us = 1000;
static volatile rt_uint32_t encoder2_debounce_us = 1000;

/**
 * @brief 设置编码器1的消抖时间
 * @param us 消抖时间 (单位: 微秒)
 */
void encoder1_set_debounce(rt_uint32_t us)
{
    encoder1_debounce_us = us;
}

/**
 * @brief 设置编码器2的消抖时间
 * @param us 消抖时间 (单位: 微秒)
 */
void encoder2_set_debounce(rt_uint32_t us)
{
    encoder2_debounce_us = us;
}

/**
 * @brief 根据 delta 值动态计算消抖时间 (微秒)
 *        delta 越大 (速度越快)，消抖时间越短
 *        delta 越小 (速度越慢)，消抖时间越长
 * @param delta 上一周期的脉冲增量
 * @return 建议的消抖时间 (微秒)
 */
static rt_uint32_t calc_debounce_us(rt_uint32_t delta)
{
    /*
     * 动态消抖策略 (微秒级):
     * - delta >= 100: 高速, 消抖 100us
     * - delta >= 50:  中高速, 消抖 200us
     * - delta >= 20:  中速, 消抖 500us
     * - delta >= 5:   低速, 消抖 1000us (1ms)
     * - delta < 5:    极低速/静止, 消抖 2000us (2ms)
     */
    if (delta >= 100)
        return 100;
    else if (delta >= 50)
        return 200;
    else if (delta >= 20)
        return 500;
    else if (delta >= 5)
        return 1000;
    else
        return 2000;
}

/**
 * @brief 编码器1 A相中断回调
 *        上升沿触发，带微秒级时间消抖
 */
static void encoder1_a_irq_callback(void *args)
{
    (void)args;
    rt_uint64_t now = SysTimer_GetLoadValue();
    rt_uint64_t threshold = (rt_uint64_t)encoder1_debounce_us * TIMER_COUNTS_PER_US;
    
    /* 消抖: 如果距离上次中断时间太短，忽略 */
    if ((now - encoder1_last_time) >= threshold)
    {
        encoder1_count++;
        encoder1_last_time = now;
    }
}

/**
 * @brief 编码器2 A相中断回调
 *        上升沿触发，带微秒级时间消抖
 */
static void encoder2_a_irq_callback(void *args)
{
    (void)args;
    rt_uint64_t now = SysTimer_GetLoadValue();
    rt_uint64_t threshold = (rt_uint64_t)encoder2_debounce_us * TIMER_COUNTS_PER_US;
    
    /* 消抖: 如果距离上次中断时间太短，忽略 */
    if ((now - encoder2_last_time) >= threshold)
    {
        encoder2_count++;
        encoder2_last_time = now;
    }
}

/**
 * @brief 初始化编码器1
 */
rt_err_t encoder1_init(void)
{
    if (encoder1_initialized)
    {
        return RT_EOK;
    }

    /* 配置 A 相为输入模式 */
    rt_pin_mode(ENCODER_GPIO_MOTOR1_A, PIN_MODE_INPUT);

    /* 绑定 A 相中断，上升沿触发 */
    rt_err_t attach_ret = rt_pin_attach_irq(ENCODER_GPIO_MOTOR1_A, PIN_IRQ_MODE_RISING,
                                            encoder1_a_irq_callback, RT_NULL);
    rt_kprintf("[Encoder1] rt_pin_attach_irq returned: %d\n", attach_ret);
    
    rt_err_t enable_ret = rt_pin_irq_enable(ENCODER_GPIO_MOTOR1_A, PIN_IRQ_ENABLE);
    rt_kprintf("[Encoder1] rt_pin_irq_enable returned: %d\n", enable_ret);
    
    if (attach_ret != RT_EOK || enable_ret != RT_EOK)
    {
        rt_kprintf("[Encoder1] WARNING: IRQ setup may have failed!\n");
    }

    encoder1_count = 0;
    encoder1_initialized = RT_TRUE;

    rt_kprintf("[Encoder1] Init OK (A=GPIO%d)\n", ENCODER_GPIO_MOTOR1_A);

    return RT_EOK;
}

/**
 * @brief 初始化编码器2
 */
rt_err_t encoder2_init(void)
{
    if (encoder2_initialized)
    {
        return RT_EOK;
    }

    /* 配置 A 相为输入模式 */
    rt_pin_mode(ENCODER_GPIO_MOTOR2_A, PIN_MODE_INPUT);

    /* 绑定 A 相中断，上升沿触发 */
    rt_pin_attach_irq(ENCODER_GPIO_MOTOR2_A, PIN_IRQ_MODE_RISING,
                      encoder2_a_irq_callback, RT_NULL);
    rt_pin_irq_enable(ENCODER_GPIO_MOTOR2_A, PIN_IRQ_ENABLE);

    encoder2_count = 0;
    encoder2_initialized = RT_TRUE;

    rt_kprintf("[Encoder2] Init OK (A=GPIO%d)\n", ENCODER_GPIO_MOTOR2_A);

    return RT_EOK;
}

/**
 * @brief 初始化两个编码器
 */
rt_err_t encoders_init(void)
{
    encoder1_init();
    encoder2_init();
    return RT_EOK;
}

/**
 * @brief 获取编码器1在一个周期内的脉冲增量
 * @return 自上次调用以来的脉冲增量
 */
rt_uint32_t encoder1_get_delta(void)
{
    rt_uint32_t current = encoder1_count;
    rt_uint32_t delta = current - encoder1_last_count;
    encoder1_last_count = current;
    
    return delta;
}

/**
 * @brief 获取编码器2在一个周期内的脉冲增量
 * @return 自上次调用以来的脉冲增量
 */
rt_uint32_t encoder2_get_delta(void)
{
    rt_uint32_t current = encoder2_count;
    rt_uint32_t delta = current - encoder2_last_count;
    encoder2_last_count = current;
    
    return delta;
}

/* ================= 编码器读取线程 ================= */

#define ENCODER_PRINT_THREAD_STACK_SIZE  4096
#define ENCODER_PRINT_THREAD_PRIORITY    12
#define ENCODER_PRINT_THREAD_TIMESLICE   5

static rt_thread_t encoder_print_thread = RT_NULL;

/* 共享的 delta 值，供底盘控制线程读取 */
static volatile rt_uint32_t shared_delta1 = 0;
static volatile rt_uint32_t shared_delta2 = 0;

/**
 * @brief 获取共享的 delta1 值
 */
rt_uint32_t encoder_get_shared_delta1(void)
{
    return shared_delta1;
}

/**
 * @brief 获取共享的 delta2 值
 */
rt_uint32_t encoder_get_shared_delta2(void)
{
    return shared_delta2;
}

/**
 * @brief 编码器读取线程入口函数
 *        以 20Hz 频率读取编码器脉冲增量
 *        同时根据速度动态调整消抖参数
 */
static void encoder_print_thread_entry(void *parameter)
{
    (void)parameter;
    while (1)
    {
        /* 读取 delta 值，更新共享变量 */
        shared_delta1 = encoder1_get_delta();
        shared_delta2 = encoder2_get_delta();

        /* 根据当前速度动态调整消抖时间 (微秒) */
        encoder1_debounce_us = calc_debounce_us(shared_delta1);
        encoder2_debounce_us = calc_debounce_us(shared_delta2);

        /* 休眠 50ms, 实现 20Hz 频率 */
        rt_thread_mdelay(50);
    }
}

/**
 * @brief 启动编码器打印线程
 * @return RT_EOK 成功, -RT_ERROR 失败
 */
rt_err_t encoder_print_thread_start(void)
{
    encoder_print_thread = rt_thread_create("enc_print",
                                            encoder_print_thread_entry,
                                            RT_NULL,
                                            ENCODER_PRINT_THREAD_STACK_SIZE,
                                            ENCODER_PRINT_THREAD_PRIORITY,
                                            ENCODER_PRINT_THREAD_TIMESLICE);
    if (encoder_print_thread != RT_NULL)
    {
        rt_thread_startup(encoder_print_thread);
        rt_kprintf("[Encoder] Print thread started (20Hz)\n");
        return RT_EOK;
    }
    else
    {
        rt_kprintf("[Encoder] Failed to create print thread!\n");
        return -RT_ERROR;
    }
}

/* ================= 调试用 MSH 命令 ================= */

/**
 * @brief MSH 命令: 读取编码器 A 相 GPIO 电平 (用于调试)
 *        用法: enc_gpio
 */
static void enc_gpio_cmd(int argc, char *argv[])
{
    (void)argc;
    (void)argv;
    rt_uint8_t a1 = rt_pin_read(ENCODER_GPIO_MOTOR1_A);
    rt_uint8_t a2 = rt_pin_read(ENCODER_GPIO_MOTOR2_A);
    
    rt_kprintf("Encoder1: A(GPIO%d)=%d\n", ENCODER_GPIO_MOTOR1_A, a1);
    rt_kprintf("Encoder2: A(GPIO%d)=%d\n", ENCODER_GPIO_MOTOR2_A, a2);
}
MSH_CMD_EXPORT_ALIAS(enc_gpio_cmd, enc_gpio, Read encoder A-phase GPIO levels for debug);
